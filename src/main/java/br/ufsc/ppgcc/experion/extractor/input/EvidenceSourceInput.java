package br.ufsc.ppgcc.experion.extractor.input;

import br.ufsc.ppgcc.experion.extractor.input.engine.EvidenceSourceInputEngine;
import br.ufsc.ppgcc.experion.extractor.source.EvidenceSource;
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;

import javax.persistence.*;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;

/**
 * As input is an expertise extractino technique (EvidenceSourceInputEngine) applied over a given source (EvidenceSource).
 *
 * This class registers and parametrizes the possible forms which expertise can be extracted for a given source of expertise evidences.
 *
 * @author Rodrigo Gon√ßalves
 * @version 2019-03-05 - First version
 *
 */
@Entity
public class EvidenceSourceInput implements Serializable {

    /** Primary key - auto-generated by JPA */
    @Id
    @GeneratedValue
    private Integer id;

    /** The identifier (name) for this input - usually in the form sourceName-extractionTechniqueName */
    @Column(unique=true)
    private String name;

    /** The engine class (full name) resposible for extracting the expertise evidences */
    private String engineClassName;

    /** Parameters required by the engine, if necessary. If present, the system will try to a constructor that receives
        a string as parameter in the configured engine class. **/
    @Lob
    private String params;

    /** Self-instatiated engine, built the first time it is required by the getEngine() method */
    @Transient
    @JsonIgnore
    private EvidenceSourceInputEngine engine;

    /** The source from which this input retrieves data. */
    @ManyToOne
    @JsonBackReference
    private EvidenceSource source;

    public EvidenceSourceInput(String name, String engineClassName) {
        this.name = name;
        this.engineClassName = engineClassName;
    }

    public EvidenceSourceInput() {
    }

    public EvidenceSourceInputEngine getEngine() {
        if (engine == null) {
            try {
                boolean parametrizedConstructor = false;
                try {
                    parametrizedConstructor = Class.forName(this.getEngineClassName()).getConstructor(String.class) != null;
                } catch (Exception e) {

                }

                if (parametrizedConstructor) {
                    engine = (EvidenceSourceInputEngine) Class.forName(this.getEngineClassName()).getConstructor(String.class).newInstance(this.params);
                } else {
                    engine = (EvidenceSourceInputEngine) Class.forName(this.getEngineClassName()).getConstructor().newInstance();
                }
                engine.setEvidenceSource(this.source);
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }
        return engine;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEngineClassName() {
        return engineClassName;
    }

    public void setEngineClassName(String engineClassName) {
        this.engineClassName = engineClassName;
    }

    public String getParams() {
        return params;
    }

    public void setParams(String params) {
        this.params = params;
    }

    public void setEngine(EvidenceSourceInputEngine engine) {
        this.engine = engine;
    }

    public EvidenceSource getSource() {
        return source;
    }

    public void setSource(EvidenceSource source) {
        this.source = source;
    }

    @Override
    public String toString() {
        return "EvidenceSourceInput{" +
                "name='" + name + '\'' +
                ", engineClassName='" + engineClassName + '\'' +
                ", source=" + source +
                '}';
    }
}
